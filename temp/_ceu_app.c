/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "movable_object.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_INTS
#define CEU_EXTS
#define CEU_CLEAR
#define CEU_ORGS
#define CEU_GOTO
#define CEU_RET
#define CEU_STACK_CLEAR
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 8

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif

#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


#define CEU_IN__NONE 0
#define CEU_IN__ORG 255
#define CEU_IN__ORG_PSED 254
#define CEU_IN__CLEAR 253
#define CEU_IN__ok_killed 252
#define CEU_IN__INIT 251
#define CEU_IN__ASYNC 250
#define CEU_IN__THREAD 249
#define CEU_IN__WCLOCK 248
#define CEU_IN_SDL_REDRAW 247
#define CEU_IN_SDL_QUIT 246
#define CEU_IN_SDL_KEYDOWN 245
#define CEU_IN_SDL_KEYUP 244
#define CEU_IN_SDL_MOUSEBUTTONDOWN 243
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 243
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_SDL_SetRenderDrawColor
#define CEU_FUN_SDL_CreateWindow
#define CEU_FUN_SDL_GetWindowSize
#define CEU_FUN_SDL_RenderFillRect
#define CEU_FUN_SDL_RenderPresent
#define CEU_FUN_SDL_Color
#define CEU_FUN_SDL_DestroyRenderer
#define CEU_FUN_SDL_CreateRenderer
#define CEU_FUN_SDL_DestroyWindow
   /* CEU_FUN_ */
typedef struct {
	SDL_MouseButtonEvent* _1;
} tceu__SDL_MouseButtonEvent_;
typedef struct {
	int _1;
	int _2;
	int _3;
	int _4;
} tceu__int__int__int__int;
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	s32 _1;
} tceu__s32;
typedef struct {
	int _1;
	int _2;
} tceu__int__int;
typedef struct {
	SDL_KeyboardEvent* _1;
} tceu__SDL_KeyboardEvent_;
typedef struct {
	u8 _1;
	u8 _2;
	u8 _3;
	u8 _4;
} tceu__u8__u8__u8__u8;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */


typedef                           struct { /* BLOCK ln=4 */
                            u8 r;
                            u8 g;
                            u8 b;
                            u8 a;
                          }  CEU_SDL_Color;


typedef                           struct { /* BLOCK ln=11 */
                            int x;
                            int y;
                          }  CEU_SDL_Point;


typedef                           struct { /* BLOCK ln=16 */
                            int x;
                            int y;
                            int w;
                            int h;
                          }  CEU_SDL_Rect;

enum {
CEU_NONE1304,
CEU__OPTION___SDL_WINDOW__REF_NIL,
CEU__OPTION___SDL_WINDOW__REF_SOME
};

typedef struct CEU__Option___SDL_Window__ref {
    u8 tag;
    union {
                              struct { /* BLOCK ln=12 */
                              } NIL;
                              struct { /* BLOCK ln=12 */
                                SDL_Window* v;
                              } SOME;
    };
}
 CEU__Option___SDL_Window__ref;

enum {
CEU_NONE1310,
CEU__OPTION___SDL_RENDERER__REF_NIL,
CEU__OPTION___SDL_RENDERER__REF_SOME
};

typedef struct CEU__Option___SDL_Renderer__ref {
    u8 tag;
    union {
                              struct { /* BLOCK ln=25 */
                              } NIL;
                              struct { /* BLOCK ln=25 */
                                SDL_Renderer* v;
                              } SOME;
    };
}
 CEU__Option___SDL_Renderer__ref;

typedef struct CEU_Rect {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
                            struct { /* BLOCK ln=35 */
                              SDL_Renderer* ren;
                              CEU_SDL_Rect rect;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=35 */
                                  union {
                                    struct { /* BLOCK ln=39 */
                                      SDL_Color clr;
                                      int h;
                                      int wn;
                                      int w;
                                      int hn;
                                      union {
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=51 */
                                            union {
                                              struct {
                                                struct { /* BLOCK ln=52 */
                                                  union {
                                                    struct { /* BLOCK ln=52 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=53 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=56 */
                                                                  union {
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=60 */
                                                  union {
                                                    struct { /* BLOCK ln=60 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=61 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=67 */
                                            union {
                                              struct { /* BLOCK ln=67 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=68 */
                                                      union {
                                                        struct {
                                                          struct { /* BLOCK ln=69 */
                                                            SDL_KeyboardEvent* key_30;
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=71 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=73 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=75 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                      struct { /* BLOCK ln=77 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=80 */
                                                            SDL_KeyboardEvent* key_31;
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=82 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=84 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=86 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=90 */
                                                            SDL_MouseButtonEvent* but_32;
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=92 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=95 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=98 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                            };
                                                          } ;
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=105 */
                                            union {
                                              struct { /* BLOCK ln=105 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=106 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Rect;




typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 8 ];
    struct { /* BLOCK ln=1 */
      union {
          union {
          };
        struct { /* BLOCK ln=1 */
          int _ret_0;
          union {
              struct { /* BLOCK ln=1 */
                union {
                  union {
                    struct { /* BLOCK ln=1 */
                    u8 __fin_526_1: 1;
                    u8 __fin_526_2: 1;
                      CEU__Option___SDL_Window__ref win;
                      int w;
                      int h;
                      CEU__Option___SDL_Renderer__ref ren;
                      CEU_SDL_Rect bg;
                      CEU_SDL_Color bg_clr;
                      union {
                            union {
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                            };
                            union {
                              union {
                              };
                              union {
                              };
                            };
                            union {
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                            };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                                union {
                                };
                                union {
                                };
                        };
                            struct { /* BLOCK ln=19 */
                              union {
                              };
                            } ;
                        union {
                        };
                        union {
                                union {
                                };
                                union {
                                };
                        };
                            struct { /* BLOCK ln=29 */
                              union {
                              };
                            } ;
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        struct {
                          struct { /* BLOCK ln=121 */
                            union {
                              union {
                              };
                            };
                          } ;
                          struct { /* BLOCK ln=123 */
                            union {
                              struct { /* BLOCK ln=123 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=124 */
                                      union {
                                        union {
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=129 */
                            struct CEU_Rect r1_19;
                            union {
                                  struct { /* BLOCK ln=130 */
                                    union {
                                    };
                                  } ;
                              struct { /* BLOCK ln=134 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=135 */
                                      union {
                                        union {
                                          union {
                                          };
                                        };
                                          struct { /* BLOCK ln=137 */
                                            union {
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=143 */
                            union {
                              struct { /* BLOCK ln=143 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=144 */
                                      union {
                                        union {
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                        };
                        union {
                        };
                      };
                    } ;
                  };
                };
              } ;
          };
        } ;
      };
    } ;

} CEU_Main;






#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
static int ceu_org_is_cleared (tceu_org* me, tceu_org* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    if (me == clr_org) {
        return (clr_t1==0 && clr_t2==me->n-1);
    }

    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK_CLEAR
void ceu_sys_stack_dump (tceu_stk* stk) {
    printf(">>> STACK DUMP:\n");
    for (; stk!=NULL; stk=stk->down) {
        printf("\t[%p] down=%p org=%p trls=[%d,%d]\n",
            stk, stk->down, stk->org, stk->trl1, stk->trl2);
    }
}

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_sys_stack_clear (tceu_stk* stk, tceu_org* org,
                          tceu_ntrl t1, tceu_ntrl t2) {
    for (; stk->down!=NULL; stk=stk->down) {
        if (!stk->is_alive) {
            continue;
        }
#ifdef CEU_ORGS
        if (stk->org != org) {
            if (ceu_org_is_cleared(stk->org, org, t1, t2)) {
                stk->is_alive = 0;
            }
        }
        else
#endif
        {
            if (t1<=stk->trl1 && stk->trl2<=t2) {
                stk->is_alive = 0;
            }
        }
    }
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl0,trlF);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    tceu_ntrl trlI;
    tceu_trl* trl;
    for (trlI=trl0, trl=&org->trls[trlI];
#ifdef CEU_STACK_CLEAR
         stk->is_alive &&
#endif
            trlI<trlF;
         trlI++, trl++)
    {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */
            if (cur != NULL) {
#ifdef CEU_STACK_CLEAR
                tceu_stk stk_ = { stk, org, cur->parent_trl, cur->parent_trl, 1 };
#endif
                while (cur != NULL) {
                    tceu_org* nxt = cur->nxt;   /* save before possible free/relink */
#ifdef CEU_STACK_CLEAR
                    ceu_sys_go_ex(app, evt, &stk_, cur, 0, cur->n);
                    if (!stk->is_alive) {
                        return; /* whole outer traversal aborted */
                    }
#if 0
if (!stk_.is_alive) {
printf("aborted\n");
    break; /* all children traversal aborted */
}
#endif
#else
                    ceu_sys_go_ex(app, evt, NULL, cur, 0, cur->n);
#endif
                    cur = nxt;
                }
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ADTS_AWAIT
                trl->is_org &&
#endif
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 ceu_org_is_cleared((tceu_org*)trl->org_or_adt,
                    (tceu_org*)((tceu_kill*)evt->param)->org_or_adt,
                    ((tceu_kill*)evt->param)->t1,
                    ((tceu_kill*)evt->param)->t2)))
        ||
#endif
#ifdef CEU_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ORGS_AWAIT
                !trl->is_org &&
#endif
                trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt)
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = app->addr;
#endif

            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);
#ifdef CEU_STACK_CLEAR
            if (!stk->is_alive) {
                return;
            }
#endif

#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = 0;
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }

#ifdef CEU_ORGS
    /* clearing the whole org? */
    if (evt->id==CEU_IN__CLEAR && org!=app->data && trl0==0 && trlF==org->n) {
        /* yes, relink and put it in the free list */
        ceu_sys_org_free(app, org);
    }
#endif
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, 0,
#ifdef CEU_ORGS
                      app->data->n
#else
                      CEU_NTRAILS
#endif
        );
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { NULL, NULL, 0, 0, 1 };
    ceu_sys_go_stk(app, evt, evtp, &stk_);
#else
    ceu_sys_go_stk(app, evt, evtp, NULL);
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_org_init,
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */

#line 117 "sdl.ceu"

    int SDL_Rect_vs_Mouse (SDL_Rect* r, SDL_MouseButtonEvent* but) {
        return (but->x >= r->x) && (but->x <= r->x+r->w)
            && (but->y >= r->y) && (but->y <= r->y+r->h);
    }
    int SDL_Rect_vs_Point (SDL_Rect* r, SDL_Point* pt) {
        return (pt->x >= r->x) && (pt->x <= r->x+r->w)
            && (pt->y >= r->y) && (pt->y <= r->y+r->h);
    }
    SDL_Point* SDL_Touch2Point (SDL_Point* pt, SDL_TouchFingerEvent* e, int w, int h) {
        pt->x = e->x * w;
        pt->y = e->y * h;
        return pt;
    }

    SDL_Point SDL_Rect2Point (SDL_Rect* r) {
        SDL_Point pt = { r->x+r->w/2, r->y+r->h/2 };
        return pt;
    }
    SDL_Rect SDL_Point2Rect (SDL_Point* pt, int radix) {
        SDL_Rect r = { pt->x-radix, pt->y-radix, radix*2, radix*2 };
        return r;
    }
#ifdef SDL_MATH
    int SDL_Circle_vs_Mouse (SDL_Point* pos, int rad, SDL_MouseButtonEvent* but) {
        SDL_Point pt = { but->x, but->y };
        return SDL_Circle_vs_Point(pos, rad, &pt);
    }

    int SDL_Circle_vs_Point (SDL_Point* pos, int rad, SDL_Point* pt) {
        return (pow(pos->x-pt->x,2) + pow(pos->y-pt->y,2)) <= pow(rad+rad,2);
    }

    int SDL_Circle_vs_Circle (SDL_Point* pos1, int rad1, SDL_Point* pos2, int rad2) {
        return (pow(pos1->x-pos2->x,2) + pow(pos1->y-pos2->y,2))
                <= pow(rad1+rad2,2);
    }
#endif

/* goto labels */
enum {
    Main_Set_out_0 = 0,
    Rect_ParOr_sub_1_1 = 1,
    Rect_ParOr_sub_2_2 = 2,
    Rect_ParOr_out_3 = 3,
    Rect_ParOr_sub_1_4 = 4,
    Rect_ParOr_out_5 = 5,
    Rect_Awake_go_oriz_6 = 6,
    Rect_Awake_go_vert_7 = 7,
    Rect_ParOr_sub_1_8 = 8,
    Rect_ParOr_sub_2_9 = 9,
    Rect_ParOr_out_10 = 10,
    Rect_Awake_SDL_KEYDOWN_11 = 11,
    Rect_Awake_SDL_KEYUP_12 = 12,
    Rect_Awake_SDL_MOUSEBUTTONDOWN_13 = 13,
    Rect_Awake_SDL_REDRAW_14 = 14,
    Class_Rect = 15,
    Main_ParOr_sub_1_16 = 16,
    Main_ParOr_sub_2_17 = 17,
    Main_ParOr_sub_3_18 = 18,
    Main_ParOr_out_19 = 19,
    Main_Awake_SDL_QUIT_20 = 20,
    Main_Awake_SDL_REDRAW_21 = 21,
    Main_Awake_SDL_KEYDOWN_22 = 22,
    Main_Awake_SDL_REDRAW_23 = 23,
    Main_Block__fin_24 = 24,
    Class_Main = 25,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

void CEU_SDL_Color_free (void* pool, CEU_SDL_Color* me);

void CEU_SDL_Color_free (void* pool, CEU_SDL_Color* me) {
}



void CEU_SDL_Point_free (void* pool, CEU_SDL_Point* me);

void CEU_SDL_Point_free (void* pool, CEU_SDL_Point* me) {
}



void CEU_SDL_Rect_free (void* pool, CEU_SDL_Rect* me);

void CEU_SDL_Rect_free (void* pool, CEU_SDL_Rect* me) {
}



void CEU__Option___SDL_Window__ref_free (void* pool, CEU__Option___SDL_Window__ref* me);

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_NIL_assert (tceu_app* app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_WINDOW__REF_NIL_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_SOME_assert (tceu_app* app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_WINDOW__REF_SOME_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option___SDL_Window__ref_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_WINDOW__REF_NIL:
            CEU__OPTION___SDL_WINDOW__REF_NIL_free(pool, me);
            break;
        case CEU__OPTION___SDL_WINDOW__REF_SOME:
            CEU__OPTION___SDL_WINDOW__REF_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option___SDL_Window__ref CEU__OPTION___SDL_WINDOW__REF_pack (SDL_Window* v) {
    CEU__Option___SDL_Window__ref ret;
    if (v == NULL) {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_NIL;
    } else
    {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_SOME;
        ret.SOME.v = v;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
SDL_Window* CEU__OPTION___SDL_WINDOW__REF_unpack (CEU__Option___SDL_Window__ref me) {
    if (me.tag == CEU__OPTION___SDL_WINDOW__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif


void CEU__Option___SDL_Renderer__ref_free (void* pool, CEU__Option___SDL_Renderer__ref* me);

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_NIL_assert (tceu_app* app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_RENDERER__REF_NIL_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_SOME_assert (tceu_app* app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_RENDERER__REF_SOME_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option___SDL_Renderer__ref_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_RENDERER__REF_NIL:
            CEU__OPTION___SDL_RENDERER__REF_NIL_free(pool, me);
            break;
        case CEU__OPTION___SDL_RENDERER__REF_SOME:
            CEU__OPTION___SDL_RENDERER__REF_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option___SDL_Renderer__ref CEU__OPTION___SDL_RENDERER__REF_pack (SDL_Renderer* v) {
    CEU__Option___SDL_Renderer__ref ret;
    if (v == NULL) {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
    } else
    {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_SOME;
        ret.SOME.v = v;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
SDL_Renderer* CEU__OPTION___SDL_RENDERER__REF_unpack (CEU__Option___SDL_Renderer__ref me) {
    if (me.tag == CEU__OPTION___SDL_RENDERER__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif




/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_488 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 488 */
/* NODE: Block 487 */

#line 130 "movable_object.ceu"
    {/* NODE: Stmts 486 */

#line 130 "movable_object.ceu"
    {/* NODE: Set 1199 */

#line 130 "movable_object.ceu"
/* SET: . *//* NODE: Op1_& 473 */

#line 130 "movable_object.ceu"
    (((*((CEU_Rect*)__ceu_this)).ren)) = ((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->ren),__FILE__,__LINE__)->SOME.v));/* NODE: Set 1200 */

#line 131 "movable_object.ceu"
/* SET: . *//* NODE: Adt_constr_root 484 */

#line 131 "movable_object.ceu"
    {/* NODE: Adt_constr_one 483 */

#line 131 "movable_object.ceu"
    CEU_SDL_Rect __ceu_adt_483;

#line 131 "movable_object.ceu"
    {/* NODE: ExpList 482 */
/* NODE: NUMBER 478 */
/* NODE: NUMBER 479 */
/* NODE: NUMBER 480 */
/* NODE: NUMBER 481 */

#line 131 "movable_object.ceu"
    __ceu_adt_483.x = 100;
#line 131 "movable_object.ceu"
    __ceu_adt_483.y = 100;
#line 131 "movable_object.ceu"
    __ceu_adt_483.w = 20;
#line 131 "movable_object.ceu"
    __ceu_adt_483.h = 20;
#line 131 "movable_object.ceu"
    }
#line 131 "movable_object.ceu"
    (((*((CEU_Rect*)__ceu_this)).rect)) = __ceu_adt_483;
#line 131 "movable_object.ceu"
    }
#line 130 "movable_object.ceu"
    }
#line 130 "movable_object.ceu"
/* CLEAR: Block (130) */
#line 130 "movable_object.ceu"
    if (0) {

#line 130 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        /* NODE: Root 539 */
/* NODE: Dcl_cls 0 */

#line 1 "movable_object.ceu"
case Class_Main:;/* NODE: Block 1298 */

#line 1 "movable_object.ceu"
    {/* NODE: Stmts 1297 */

#line 1 "movable_object.ceu"
    {/* NODE: Block 545 */

#line 1 "movable_object.ceu"
    {/* NODE: Stmts 544 */

#line 1 "movable_object.ceu"
    {/* NODE: Dcl_var 541 */
/* NODE: SetBlock 543 */
/* NODE: Block 537 */

#line 1 "movable_object.ceu"
    {/* NODE: Stmts 536 */

#line 1 "movable_object.ceu"
    {/* NODE: Stmts 533 */

#line 1 "movable_object.ceu"
    {/* NODE: Block 526 */

#line 1 "movable_object.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 7 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 7 ].lbl = Main_Block__fin_24;

#line 1 "movable_object.ceu"
    ((CEU_Main*)_ceu_org)->__fin_526_1 = 0;
#line 1 "movable_object.ceu"
    ((CEU_Main*)_ceu_org)->__fin_526_2 = 0;
#line 1 "movable_object.ceu"
    {
#line 1 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->win).tag = CEU__OPTION___SDL_WINDOW__REF_NIL;

#line 1 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->ren).tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
/* NODE: Stmts 524 */

#line 4 "sdl.ceu"
    {/* NODE: Dcl_adt 8 */
/* NODE: Dcl_adt 13 */
/* NODE: Dcl_adt 22 */
/* NODE: Stmts 579 */

#line 23 "sdl.ceu"
    {/* NODE: Dcl_nat 577 */
/* NODE: Dcl_nat 578 */

#line 23 "sdl.ceu"
    }/* NODE: Stmts 583 */

#line 24 "sdl.ceu"
    {/* NODE: Dcl_nat 580 */
/* NODE: Dcl_nat 581 */
/* NODE: Dcl_nat 582 */

#line 24 "sdl.ceu"
    }/* NODE: Stmts 591 */

#line 26 "sdl.ceu"
    {/* NODE: Dcl_nat 584 */
/* NODE: Dcl_nat 585 */
/* NODE: Dcl_nat 586 */
/* NODE: Dcl_nat 587 */
/* NODE: Dcl_nat 588 */
/* NODE: Dcl_nat 589 */
/* NODE: Dcl_nat 590 */

#line 26 "sdl.ceu"
    }/* NODE: Stmts 611 */

#line 32 "sdl.ceu"
    {/* NODE: Dcl_nat 592 */
/* NODE: Dcl_nat 593 */
/* NODE: Dcl_nat 594 */
/* NODE: Dcl_nat 595 */
/* NODE: Dcl_nat 596 */
/* NODE: Dcl_nat 597 */
/* NODE: Dcl_nat 598 */
/* NODE: Dcl_nat 599 */
/* NODE: Dcl_nat 600 */
/* NODE: Dcl_nat 601 */
/* NODE: Dcl_nat 602 */
/* NODE: Dcl_nat 603 */
/* NODE: Dcl_nat 604 */
/* NODE: Dcl_nat 605 */
/* NODE: Dcl_nat 606 */
/* NODE: Dcl_nat 607 */
/* NODE: Dcl_nat 608 */
/* NODE: Dcl_nat 609 */
/* NODE: Dcl_nat 610 */

#line 32 "sdl.ceu"
    }/* NODE: Stmts 616 */

#line 50 "sdl.ceu"
    {/* NODE: Dcl_nat 612 */
/* NODE: Dcl_nat 613 */
/* NODE: Dcl_nat 614 */
/* NODE: Dcl_nat 615 */

#line 50 "sdl.ceu"
    }/* NODE: Stmts 669 */

#line 55 "sdl.ceu"
    {/* NODE: Dcl_nat 617 */
/* NODE: Dcl_nat 618 */
/* NODE: Dcl_nat 619 */
/* NODE: Dcl_nat 620 */
/* NODE: Dcl_nat 621 */
/* NODE: Dcl_nat 622 */
/* NODE: Dcl_nat 623 */
/* NODE: Dcl_nat 624 */
/* NODE: Dcl_nat 625 */
/* NODE: Dcl_nat 626 */
/* NODE: Dcl_nat 627 */
/* NODE: Dcl_nat 628 */
/* NODE: Dcl_nat 629 */
/* NODE: Dcl_nat 630 */
/* NODE: Dcl_nat 631 */
/* NODE: Dcl_nat 632 */
/* NODE: Dcl_nat 633 */
/* NODE: Dcl_nat 634 */
/* NODE: Dcl_nat 635 */
/* NODE: Dcl_nat 636 */
/* NODE: Dcl_nat 637 */
/* NODE: Dcl_nat 638 */
/* NODE: Dcl_nat 639 */
/* NODE: Dcl_nat 640 */
/* NODE: Dcl_nat 641 */
/* NODE: Dcl_nat 642 */
/* NODE: Dcl_nat 643 */
/* NODE: Dcl_nat 644 */
/* NODE: Dcl_nat 645 */
/* NODE: Dcl_nat 646 */
/* NODE: Dcl_nat 647 */
/* NODE: Dcl_nat 648 */
/* NODE: Dcl_nat 649 */
/* NODE: Dcl_nat 650 */
/* NODE: Dcl_nat 651 */
/* NODE: Dcl_nat 652 */
/* NODE: Dcl_nat 653 */
/* NODE: Dcl_nat 654 */
/* NODE: Dcl_nat 655 */
/* NODE: Dcl_nat 656 */
/* NODE: Dcl_nat 657 */
/* NODE: Dcl_nat 658 */
/* NODE: Dcl_nat 659 */
/* NODE: Dcl_nat 660 */
/* NODE: Dcl_nat 661 */
/* NODE: Dcl_nat 662 */
/* NODE: Dcl_nat 663 */
/* NODE: Dcl_nat 664 */
/* NODE: Dcl_nat 665 */
/* NODE: Dcl_nat 666 */
/* NODE: Dcl_nat 667 */
/* NODE: Dcl_nat 668 */

#line 55 "sdl.ceu"
    }/* NODE: Stmts 678 */

#line 108 "sdl.ceu"
    {/* NODE: Dcl_nat 670 */
/* NODE: Dcl_nat 671 */
/* NODE: Dcl_nat 672 */
/* NODE: Dcl_nat 673 */
/* NODE: Dcl_nat 674 */
/* NODE: Dcl_nat 675 */
/* NODE: Dcl_nat 676 */
/* NODE: Dcl_nat 677 */

#line 108 "sdl.ceu"
    }/* NODE: Host 30 */
/* NODE: Stmts 681 */

#line 3 "movable_object.ceu"
    {/* NODE: Dcl_ext 680 */

#line 3 "movable_object.ceu"
    }/* NODE: Stmts 684 */

#line 4 "movable_object.ceu"
    {/* NODE: Dcl_ext 683 */

#line 4 "movable_object.ceu"
    }/* NODE: Stmts 688 */

#line 5 "movable_object.ceu"
    {/* NODE: Dcl_ext 687 */

#line 5 "movable_object.ceu"
    }/* NODE: Stmts 692 */

#line 6 "movable_object.ceu"
    {/* NODE: Dcl_ext 691 */

#line 6 "movable_object.ceu"
    }/* NODE: Stmts 696 */

#line 7 "movable_object.ceu"
    {/* NODE: Dcl_ext 695 */

#line 7 "movable_object.ceu"
    }/* NODE: Stmts 699 */

#line 9 "movable_object.ceu"
    {/* NODE: Dcl_ext 698 */

#line 9 "movable_object.ceu"
    }/* NODE: Stmts 702 */

#line 10 "movable_object.ceu"
    {/* NODE: Dcl_ext 701 */

#line 10 "movable_object.ceu"
    }/* NODE: Stmts 705 */

#line 12 "movable_object.ceu"
    {/* NODE: Dcl_adt 1304 */
/* NODE: Dcl_var 704 */

#line 12 "movable_object.ceu"
    }/* NODE: Finalize 69 */

#line 13 "movable_object.ceu"
    ((CEU_Main*)_ceu_org)->__fin_526_2 = 1;/* NODE: Set 706 */

#line 14 "movable_object.ceu"
/* SET: win *//* NODE: Op1_& 57 */

#line 14 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->win) = (CEU__OPTION___SDL_WINDOW__REF_pack(SDL_CreateWindow("SDL 2",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,800,480,SDL_WINDOW_SHOWN)));/* NODE: Stmts 715 */

#line 22 "movable_object.ceu"
    {/* NODE: Dcl_var 708 */
/* NODE: Set 716 */

#line 22 "movable_object.ceu"
/* SET: w *//* NODE: NUMBER 71 */

#line 22 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->w) = 0;/* NODE: Dcl_var 712 */
/* NODE: Set 717 */

#line 22 "movable_object.ceu"
/* SET: h *//* NODE: NUMBER 72 */

#line 22 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->h) = 0;
#line 22 "movable_object.ceu"
    }/* NODE: CallStmt 84 */

#line 23 "movable_object.ceu"
    SDL_GetWindowSize(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->win),__FILE__,__LINE__)->SOME.v)),(&((CEU_Main*)_ceu_org)->w),(&((CEU_Main*)_ceu_org)->h));/* NODE: Stmts 720 */

#line 25 "movable_object.ceu"
    {/* NODE: Dcl_adt 1310 */
/* NODE: Dcl_var 719 */

#line 25 "movable_object.ceu"
    }/* NODE: Finalize 109 */

#line 26 "movable_object.ceu"
    ((CEU_Main*)_ceu_org)->__fin_526_1 = 1;/* NODE: Set 721 */

#line 27 "movable_object.ceu"
/* SET: ren *//* NODE: Op1_& 97 */

#line 27 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->ren) = (CEU__OPTION___SDL_RENDERER__REF_pack(SDL_CreateRenderer(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->win),__FILE__,__LINE__)->SOME.v)),(-1),0)));/* NODE: Stmts 726 */

#line 32 "movable_object.ceu"
    {/* NODE: Dcl_var 723 */
/* NODE: Set 727 */

#line 32 "movable_object.ceu"
/* SET: bg *//* NODE: Adt_constr_root 118 */

#line 32 "movable_object.ceu"
    {/* NODE: Adt_constr_one 117 */

#line 32 "movable_object.ceu"
    CEU_SDL_Rect __ceu_adt_117;

#line 32 "movable_object.ceu"
    {/* NODE: ExpList 116 */
/* NODE: NUMBER 112 */
/* NODE: NUMBER 113 */
/* NODE: Var 114 */
/* NODE: Var 115 */

#line 32 "movable_object.ceu"
    __ceu_adt_117.x = 0;
#line 32 "movable_object.ceu"
    __ceu_adt_117.y = 0;
#line 32 "movable_object.ceu"
    __ceu_adt_117.w = (((CEU_Main*)_ceu_org)->w);
#line 32 "movable_object.ceu"
    __ceu_adt_117.h = (((CEU_Main*)_ceu_org)->h);
#line 32 "movable_object.ceu"
    }
#line 32 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->bg) = __ceu_adt_117;
#line 32 "movable_object.ceu"
    }
#line 32 "movable_object.ceu"
    }/* NODE: Stmts 732 */

#line 33 "movable_object.ceu"
    {/* NODE: Dcl_var 729 */
/* NODE: Set 733 */

#line 33 "movable_object.ceu"
/* SET: bg_clr *//* NODE: Adt_constr_root 128 */

#line 33 "movable_object.ceu"
    {/* NODE: Adt_constr_one 127 */

#line 33 "movable_object.ceu"
    CEU_SDL_Color __ceu_adt_127;

#line 33 "movable_object.ceu"
    {/* NODE: ExpList 126 */
/* NODE: NUMBER 122 */
/* NODE: NUMBER 123 */
/* NODE: NUMBER 124 */
/* NODE: NUMBER 125 */

#line 33 "movable_object.ceu"
    __ceu_adt_127.r = 0x00;
#line 33 "movable_object.ceu"
    __ceu_adt_127.g = 0x00;
#line 33 "movable_object.ceu"
    __ceu_adt_127.b = 0x00;
#line 33 "movable_object.ceu"
    __ceu_adt_127.a = 0xFF;
#line 33 "movable_object.ceu"
    }
#line 33 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->bg_clr) = __ceu_adt_127;
#line 33 "movable_object.ceu"
    }
#line 33 "movable_object.ceu"
    }/* NODE: Stmts 1137 */

#line 35 "movable_object.ceu"
    {
#line 35 "movable_object.ceu"
    }/* NODE: ParOr 521 */

#line 120 "movable_object.ceu"
/* ParOr: spawn subs */
#line 120 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 6, 1 };
#endif

#line 120 "movable_object.ceu"
        _ceu_org->trls[ 0 ].lbl = Main_ParOr_sub_1_16;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 120 "movable_object.ceu"
        _ceu_org->trls[ 1 ].lbl = Main_ParOr_sub_2_17;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 120 "movable_object.ceu"
        _ceu_org->trls[ 2 ].lbl = Main_ParOr_sub_3_18;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 120 "movable_object.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 120 "movable_object.ceu"
    }
/* NODE: Block 520 */

#line 143 "movable_object.ceu"
    {/* NODE: Stmts 519 */

#line 143 "movable_object.ceu"
    {/* NODE: Block 1265 */

#line 143 "movable_object.ceu"
    {/* NODE: Stmts 1264 */

#line 143 "movable_object.ceu"
    {/* NODE: Stmts 1263 */

#line 143 "movable_object.ceu"
    {
#line 143 "movable_object.ceu"
    }/* NODE: Loop 1262 */

#line 143 "movable_object.ceu"
    for (;;) {
/* NODE: Block 517 */

#line 144 "movable_object.ceu"
    {/* NODE: Stmts 516 */

#line 144 "movable_object.ceu"
    {/* NODE: Stmts 1292 */

#line 143 "movable_object.ceu"
    {/* NODE: Nothing 1266 */
/* NODE: Await 1259 */

#line 143 "movable_object.ceu"
    _CEU_NO_1259_:
if (0) { goto _CEU_NO_1259_; /* avoids "not used" warning */ }

#line 143 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Main_Awake_SDL_REDRAW_23;
_ceu_trl->seqno = _ceu_app->seqno;

#line 143 "movable_object.ceu"
    return;

case Main_Awake_SDL_REDRAW_23:;

#line 143 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1366 */
/* NODE: Nothing 1367 */

#line 143 "movable_object.ceu"
    }/* NODE: CallStmt 515 */

#line 144 "movable_object.ceu"
    SDL_RenderPresent(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->ren),__FILE__,__LINE__)->SOME.v)));
#line 144 "movable_object.ceu"
    }
#line 144 "movable_object.ceu"
/* CLEAR: Block (144) */
#line 144 "movable_object.ceu"
    if (0) {

#line 144 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 143 "movable_object.ceu"
    }

#line 143 "movable_object.ceu"
    }
#line 143 "movable_object.ceu"
/* CLEAR: Block (143) */
#line 143 "movable_object.ceu"
    if (0) {

#line 143 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 143 "movable_object.ceu"
    }
#line 143 "movable_object.ceu"
/* CLEAR: Block (143) */
#line 143 "movable_object.ceu"
    if (0) {

#line 143 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 120 "movable_object.ceu"
case Main_ParOr_sub_3_18:;/* NODE: Block 507 */

#line 129 "movable_object.ceu"
    {
#line 129 "movable_object.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 129 "movable_object.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 506 */

#line 129 "movable_object.ceu"
    {/* NODE: Dcl_var 489 */

#line 129 "movable_object.ceu"
/* start org: r1 */
#line 129 "movable_object.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19)),7,Class_Rect,
                     1,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 129 "movable_object.ceu"
        _ceu_constr_488(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19)), _ceu_org);

#line 129 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 3, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->r1_19))->trls[0],
               NULL);
#endif

#line 129 "movable_object.ceu"
    }
/* NODE: Block 1204 */

#line 134 "movable_object.ceu"
    {/* NODE: Stmts 1203 */

#line 134 "movable_object.ceu"
    {/* NODE: Stmts 1202 */

#line 134 "movable_object.ceu"
    {
#line 134 "movable_object.ceu"
    }/* NODE: Loop 1201 */

#line 134 "movable_object.ceu"
    for (;;) {
/* NODE: Block 504 */

#line 135 "movable_object.ceu"
    {
#line 135 "movable_object.ceu"
    SDL_KeyboardEvent* __ceu_key_20;
/* NODE: Stmts 503 */

#line 135 "movable_object.ceu"
    {/* NODE: Stmts 1209 */

#line 135 "movable_object.ceu"
    {/* NODE: Dcl_var 1206 */
/* NODE: Stmts 1250 */

#line 135 "movable_object.ceu"
    {/* NODE: Nothing 1212 */
/* NODE: Set 1211 */

#line 135 "movable_object.ceu"
/* SET: table: 0x1d2a040 *//* NODE: Await 492 */

#line 135 "movable_object.ceu"
    _CEU_NO_492_:
if (0) { goto _CEU_NO_492_; /* avoids "not used" warning */ }

#line 135 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Main_Awake_SDL_KEYDOWN_22;
_ceu_trl->seqno = _ceu_app->seqno;

#line 135 "movable_object.ceu"
    return;

case Main_Awake_SDL_KEYDOWN_22:;

#line 135 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 135 "movable_object.ceu"
    {

#line 135 "movable_object.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 135 "movable_object.ceu"
        {
        (__ceu_key_20) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: Nothing 1364 */
/* NODE: Nothing 1365 */

#line 135 "movable_object.ceu"
    }
#line 135 "movable_object.ceu"
    }/* NODE: If 1256 */

#line 136 "movable_object.ceu"
    if (((((((*(__ceu_key_20)).keysym)).sym))==SDLK_ESCAPE)) {
/* NODE: Block 501 */

#line 137 "movable_object.ceu"
    {/* NODE: Stmts 500 */

#line 137 "movable_object.ceu"
    {/* NODE: Break 499 */

#line 137 "movable_object.ceu"
    break;
#line 137 "movable_object.ceu"
    }
#line 137 "movable_object.ceu"
/* CLEAR: Block (137) */
#line 137 "movable_object.ceu"
    if (0) {

#line 137 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 1255 */
}

#line 135 "movable_object.ceu"
    }
#line 135 "movable_object.ceu"
/* CLEAR: Block (135) */
#line 135 "movable_object.ceu"
    if (0) {

#line 135 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 134 "movable_object.ceu"
    }

#line 134 "movable_object.ceu"
/* CLEAR: Loop (134) */
#line 134 "movable_object.ceu"
    }
#line 134 "movable_object.ceu"
/* CLEAR: Block (134) */
#line 134 "movable_object.ceu"
    if (0) {

#line 134 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 129 "movable_object.ceu"
    }
#line 129 "movable_object.ceu"
/* CLEAR: Block (129) */
#line 129 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}

#line 129 "movable_object.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 2,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 129 "movable_object.ceu"
    if (0) {

#line 129 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 120 "movable_object.ceu"
/* PAROR JOIN */
#line 120 "movable_object.ceu"
    _ceu_lbl = Main_ParOr_out_19;
goto _CEU_GOTO_;

#line 120 "movable_object.ceu"
case Main_ParOr_sub_2_17:;/* NODE: Block 467 */

#line 123 "movable_object.ceu"
    {/* NODE: Stmts 466 */

#line 123 "movable_object.ceu"
    {/* NODE: Block 1171 */

#line 123 "movable_object.ceu"
    {/* NODE: Stmts 1170 */

#line 123 "movable_object.ceu"
    {/* NODE: Stmts 1169 */

#line 123 "movable_object.ceu"
    {
#line 123 "movable_object.ceu"
    }/* NODE: Loop 1168 */

#line 123 "movable_object.ceu"
    for (;;) {
/* NODE: Block 464 */

#line 124 "movable_object.ceu"
    {/* NODE: Stmts 463 */

#line 124 "movable_object.ceu"
    {/* NODE: Stmts 1198 */

#line 123 "movable_object.ceu"
    {/* NODE: Nothing 1172 */
/* NODE: Await 1165 */

#line 123 "movable_object.ceu"
    _CEU_NO_1165_:
if (0) { goto _CEU_NO_1165_; /* avoids "not used" warning */ }

#line 123 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Main_Awake_SDL_REDRAW_21;
_ceu_trl->seqno = _ceu_app->seqno;

#line 123 "movable_object.ceu"
    return;

case Main_Awake_SDL_REDRAW_21:;

#line 123 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1360 */
/* NODE: Nothing 1361 */

#line 123 "movable_object.ceu"
    }/* NODE: CallStmt 451 */

#line 124 "movable_object.ceu"
    SDL_SetRenderDrawColor(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->ren),__FILE__,__LINE__)->SOME.v)),(((((CEU_Main*)_ceu_org)->bg_clr).r)),(((((CEU_Main*)_ceu_org)->bg_clr).g)),(((((CEU_Main*)_ceu_org)->bg_clr).b)),0xFF);/* NODE: CallStmt 462 */

#line 125 "movable_object.ceu"
    SDL_RenderFillRect(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->ren),__FILE__,__LINE__)->SOME.v)),((SDL_Rect*)(&((CEU_Main*)_ceu_org)->bg)));
#line 124 "movable_object.ceu"
    }
#line 124 "movable_object.ceu"
/* CLEAR: Block (124) */
#line 124 "movable_object.ceu"
    if (0) {

#line 124 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 123 "movable_object.ceu"
    }

#line 123 "movable_object.ceu"
    }
#line 123 "movable_object.ceu"
/* CLEAR: Block (123) */
#line 123 "movable_object.ceu"
    if (0) {

#line 123 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 123 "movable_object.ceu"
    }
#line 123 "movable_object.ceu"
/* CLEAR: Block (123) */
#line 123 "movable_object.ceu"
    if (0) {

#line 123 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 120 "movable_object.ceu"
case Main_ParOr_sub_1_16:;/* NODE: Block 436 */

#line 121 "movable_object.ceu"
    {/* NODE: Stmts 435 */

#line 121 "movable_object.ceu"
    {/* NODE: Stmts 1164 */

#line 121 "movable_object.ceu"
    {/* NODE: Nothing 1138 */
/* NODE: Await 434 */

#line 121 "movable_object.ceu"
    _CEU_NO_434_:
if (0) { goto _CEU_NO_434_; /* avoids "not used" warning */ }

#line 121 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_QUIT;
_ceu_trl->lbl = Main_Awake_SDL_QUIT_20;
_ceu_trl->seqno = _ceu_app->seqno;

#line 121 "movable_object.ceu"
    return;

case Main_Awake_SDL_QUIT_20:;

#line 121 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1358 */
/* NODE: Nothing 1359 */

#line 121 "movable_object.ceu"
    }
#line 121 "movable_object.ceu"
    }
#line 121 "movable_object.ceu"
/* CLEAR: Block (121) */
#line 121 "movable_object.ceu"
    if (0) {

#line 121 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 120 "movable_object.ceu"
/* PAROR JOIN */
#line 120 "movable_object.ceu"
    _ceu_lbl = Main_ParOr_out_19;
goto _CEU_GOTO_;

#line 120 "movable_object.ceu"
case Main_ParOr_out_19:;
#line 120 "movable_object.ceu"
/* CLEAR: ParOr (120) */
#line 120 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  7);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,6);
#endif
}

#line 120 "movable_object.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,6 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: Stmts 1296 */

#line 148 "movable_object.ceu"
    {/* NODE: Set 1294 */

#line 148 "movable_object.ceu"
/* SET: _ret *//* NODE: NUMBER 522 */

#line 148 "movable_object.ceu"
    (((CEU_Main*)_ceu_org)->_ret_0) = 0;
#line 148 "movable_object.ceu"
    #ifdef CEU_RET
    _ceu_app->ret = (((CEU_Main*)_ceu_org)->_ret_0);
#endif
/* NODE: Escape 1295 */

#line 148 "movable_object.ceu"
    _ceu_lbl = Main_Set_out_0;
goto _CEU_GOTO_;

#line 148 "movable_object.ceu"
    }
#line 4 "sdl.ceu"
    }
#line 1 "movable_object.ceu"
/* CLEAR: Block (1) */
#line 1 "movable_object.ceu"
    if (0) {

#line 1 "movable_object.ceu"
case Main_Block__fin_24:;
#line 1 "movable_object.ceu"
    if (((CEU_Main*)_ceu_org)->__fin_526_1) {
    /* NODE: Finally 108 */
/* NODE: Block 107 */

#line 29 "movable_object.ceu"
    {/* NODE: Stmts 106 */

#line 29 "movable_object.ceu"
    {/* NODE: CallStmt 105 */

#line 29 "movable_object.ceu"
    SDL_DestroyRenderer(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->ren),__FILE__,__LINE__)->SOME.v)));
#line 29 "movable_object.ceu"
    }
#line 29 "movable_object.ceu"
/* CLEAR: Block (29) */
#line 29 "movable_object.ceu"
    if (0) {

#line 29 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1 "movable_object.ceu"
    if (((CEU_Main*)_ceu_org)->__fin_526_2) {
    /* NODE: Finally 68 */
/* NODE: Block 67 */

#line 19 "movable_object.ceu"
    {/* NODE: Stmts 66 */

#line 19 "movable_object.ceu"
    {/* NODE: CallStmt 65 */

#line 19 "movable_object.ceu"
    SDL_DestroyWindow(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->win),__FILE__,__LINE__)->SOME.v)));
#line 19 "movable_object.ceu"
    }
#line 19 "movable_object.ceu"
/* CLEAR: Block (19) */
#line 19 "movable_object.ceu"
    if (0) {

#line 19 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1 "movable_object.ceu"
    return;
#line 1 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "movable_object.ceu"
    }
#line 1 "movable_object.ceu"
    }
#line 1 "movable_object.ceu"
/* CLEAR: Block (1) */
#line 1 "movable_object.ceu"
    if (0) {

#line 1 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "movable_object.ceu"
    return;
#line 1 "movable_object.ceu"
case Main_Set_out_0:;
#line 1 "movable_object.ceu"
/* CLEAR: SetBlock (1) */
#line 1 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  8);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,7);
#endif
}

#line 1 "movable_object.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,7 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1 "movable_object.ceu"
    }
#line 1 "movable_object.ceu"
/* CLEAR: Block (1) */
#line 1 "movable_object.ceu"
    if (0) {

#line 1 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "movable_object.ceu"
    }
#line 1 "movable_object.ceu"
/* CLEAR: Block (1) */
#line 1 "movable_object.ceu"
    if (0) {

#line 1 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "movable_object.ceu"
    #if defined(CEU_RET) || defined(CEU_OS)
_ceu_app->isAlive = 0;
#endif

#line 1 "movable_object.ceu"
    return;/* NODE: Dcl_cls 1 */

#line 35 "movable_object.ceu"
case Class_Rect:;/* NODE: Block 1135 */

#line 35 "movable_object.ceu"
    {/* NODE: Stmts 1134 */

#line 35 "movable_object.ceu"
    {/* NODE: Block 739 */

#line 35 "movable_object.ceu"
    {/* NODE: Stmts 1136 */

#line 35 "movable_object.ceu"
    {/* NODE: Block 431 */

#line 39 "movable_object.ceu"
    {/* NODE: Stmts 430 */

#line 39 "movable_object.ceu"
    {/* NODE: Stmts 753 */

#line 39 "movable_object.ceu"
    {/* NODE: Dcl_var 750 */
/* NODE: Set 754 */

#line 39 "movable_object.ceu"
/* SET: clr *//* NODE: Op2_call 141 */

#line 39 "movable_object.ceu"
    {
    SDL_Color __ceu_v_754 = 
#ifdef __cplusplus
    SDL_Color(0x00,0xFF,0xFF)
#else
    {0x00,0xFF,0xFF}
#endif
;
    (((CEU_Rect*)_ceu_org)->clr) = __ceu_v_754;
}

#line 39 "movable_object.ceu"
    }/* NODE: Stmts 758 */

#line 41 "movable_object.ceu"
    {/* NODE: Dcl_int 757 */

#line 41 "movable_object.ceu"
    }/* NODE: Stmts 762 */

#line 42 "movable_object.ceu"
    {/* NODE: Dcl_int 761 */

#line 42 "movable_object.ceu"
    }/* NODE: Stmts 767 */

#line 44 "movable_object.ceu"
    {/* NODE: Dcl_var 764 */
/* NODE: Set 768 */

#line 44 "movable_object.ceu"
/* SET: w *//* NODE: Op2_. 149 */

#line 44 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->w) = (((((CEU_Rect*)_ceu_org)->rect).w));
#line 44 "movable_object.ceu"
    }/* NODE: Stmts 773 */

#line 45 "movable_object.ceu"
    {/* NODE: Dcl_var 770 */
/* NODE: Set 774 */

#line 45 "movable_object.ceu"
/* SET: h *//* NODE: Op2_. 153 */

#line 45 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->h) = (((((CEU_Rect*)_ceu_org)->rect).h));
#line 45 "movable_object.ceu"
    }/* NODE: Stmts 779 */

#line 46 "movable_object.ceu"
    {/* NODE: Dcl_var 776 */
/* NODE: Set 780 */

#line 46 "movable_object.ceu"
/* SET: wn *//* NODE: NUMBER 156 */

#line 46 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->wn) = 0;
#line 46 "movable_object.ceu"
    }/* NODE: Stmts 785 */

#line 47 "movable_object.ceu"
    {/* NODE: Dcl_var 782 */
/* NODE: Set 786 */

#line 47 "movable_object.ceu"
/* SET: hn *//* NODE: NUMBER 159 */

#line 47 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->hn) = 0;
#line 47 "movable_object.ceu"
    }/* NODE: ParOr 429 */

#line 49 "movable_object.ceu"
/* ParOr: spawn subs */
#line 49 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 5, 1 };
#endif

#line 49 "movable_object.ceu"
        _ceu_org->trls[ 0 ].lbl = Rect_ParOr_sub_1_1;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 49 "movable_object.ceu"
        _ceu_org->trls[ 2 ].lbl = Rect_ParOr_sub_2_2;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 49 "movable_object.ceu"
        _ceu_trl = &_ceu_org->trls[ 5 ];

#line 49 "movable_object.ceu"
    }
/* NODE: Block 428 */

#line 105 "movable_object.ceu"
    {/* NODE: Stmts 427 */

#line 105 "movable_object.ceu"
    {/* NODE: Block 1106 */

#line 105 "movable_object.ceu"
    {/* NODE: Stmts 1105 */

#line 105 "movable_object.ceu"
    {/* NODE: Stmts 1104 */

#line 105 "movable_object.ceu"
    {
#line 105 "movable_object.ceu"
    }/* NODE: Loop 1103 */

#line 105 "movable_object.ceu"
    for (;;) {
/* NODE: Block 425 */

#line 106 "movable_object.ceu"
    {/* NODE: Stmts 424 */

#line 106 "movable_object.ceu"
    {/* NODE: Stmts 1133 */

#line 105 "movable_object.ceu"
    {/* NODE: Nothing 1107 */
/* NODE: Await 1100 */

#line 105 "movable_object.ceu"
    _CEU_NO_1100_:
if (0) { goto _CEU_NO_1100_; /* avoids "not used" warning */ }

#line 105 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Rect_Awake_SDL_REDRAW_14;
_ceu_trl->seqno = _ceu_app->seqno;

#line 105 "movable_object.ceu"
    return;

case Rect_Awake_SDL_REDRAW_14:;

#line 105 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1356 */
/* NODE: Nothing 1357 */

#line 105 "movable_object.ceu"
    }/* NODE: CallStmt 413 */

#line 106 "movable_object.ceu"
    SDL_SetRenderDrawColor((((CEU_Rect*)_ceu_org)->ren),(((((CEU_Rect*)_ceu_org)->clr).r)),(((((CEU_Rect*)_ceu_org)->clr).g)),(((((CEU_Rect*)_ceu_org)->clr).b)),0xFF);/* NODE: CallStmt 423 */

#line 107 "movable_object.ceu"
    SDL_RenderFillRect((((CEU_Rect*)_ceu_org)->ren),((SDL_Rect*)(&((CEU_Rect*)_ceu_org)->rect)));
#line 106 "movable_object.ceu"
    }
#line 106 "movable_object.ceu"
/* CLEAR: Block (106) */
#line 106 "movable_object.ceu"
    if (0) {

#line 106 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 105 "movable_object.ceu"
    }

#line 105 "movable_object.ceu"
    }
#line 105 "movable_object.ceu"
/* CLEAR: Block (105) */
#line 105 "movable_object.ceu"
    if (0) {

#line 105 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 105 "movable_object.ceu"
    }
#line 105 "movable_object.ceu"
/* CLEAR: Block (105) */
#line 105 "movable_object.ceu"
    if (0) {

#line 105 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "movable_object.ceu"
case Rect_ParOr_sub_2_2:;/* NODE: Block 399 */

#line 67 "movable_object.ceu"
    {/* NODE: Stmts 398 */

#line 67 "movable_object.ceu"
    {/* NODE: Block 902 */

#line 67 "movable_object.ceu"
    {/* NODE: Stmts 901 */

#line 67 "movable_object.ceu"
    {/* NODE: Stmts 900 */

#line 67 "movable_object.ceu"
    {
#line 67 "movable_object.ceu"
    }/* NODE: Loop 899 */

#line 67 "movable_object.ceu"
    for (;;) {
/* NODE: Block 396 */

#line 68 "movable_object.ceu"
    {/* NODE: Stmts 395 */

#line 68 "movable_object.ceu"
    {/* NODE: ParOr 394 */

#line 68 "movable_object.ceu"
/* ParOr: spawn subs */
#line 68 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 4, 1 };
#endif

#line 68 "movable_object.ceu"
        _ceu_org->trls[ 2 ].lbl = Rect_ParOr_sub_1_8;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 68 "movable_object.ceu"
        _ceu_org->trls[ 3 ].lbl = Rect_ParOr_sub_2_9;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 3 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 68 "movable_object.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 68 "movable_object.ceu"
    }
/* NODE: Block 393 */

#line 90 "movable_object.ceu"
    {/* NODE: Stmts 392 */

#line 90 "movable_object.ceu"
    {/* NODE: Stmts 1037 */

#line 90 "movable_object.ceu"
    {/* NODE: Dcl_var 1034 */
/* NODE: Stmts 1078 */

#line 90 "movable_object.ceu"
    {/* NODE: Nothing 1040 */
/* NODE: Set 1039 */

#line 90 "movable_object.ceu"
/* SET: table: 0x1d14920 *//* NODE: Await 307 */

#line 90 "movable_object.ceu"
    _CEU_NO_307_:
if (0) { goto _CEU_NO_307_; /* avoids "not used" warning */ }

#line 90 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_MOUSEBUTTONDOWN;
_ceu_trl->lbl = Rect_Awake_SDL_MOUSEBUTTONDOWN_13;
_ceu_trl->seqno = _ceu_app->seqno;

#line 90 "movable_object.ceu"
    return;

case Rect_Awake_SDL_MOUSEBUTTONDOWN_13:;

#line 90 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 90 "movable_object.ceu"
    {

#line 90 "movable_object.ceu"
        tceu__SDL_MouseButtonEvent_** __ceu_casted = (tceu__SDL_MouseButtonEvent_**) _ceu_evt->param;

#line 90 "movable_object.ceu"
        {
        (((CEU_Rect*)_ceu_org)->but_32) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: Nothing 1354 */
/* NODE: Nothing 1355 */

#line 90 "movable_object.ceu"
    }
#line 90 "movable_object.ceu"
    }/* NODE: If 1086 */

#line 91 "movable_object.ceu"
    if (((((*(((CEU_Rect*)_ceu_org)->but_32)).button))==SDL_BUTTON_LEFT)) {
/* NODE: Block 335 */

#line 92 "movable_object.ceu"
    {/* NODE: Stmts 334 */

#line 92 "movable_object.ceu"
    {/* NODE: Set 1089 */

#line 92 "movable_object.ceu"
/* SET: wn *//* NODE: Op2_+ 316 */

#line 92 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->wn) = ((((CEU_Rect*)_ceu_org)->wn)+5);/* NODE: Set 1090 */

#line 93 "movable_object.ceu"
/* SET: rect *//* NODE: Adt_constr_root 332 */

#line 93 "movable_object.ceu"
    {/* NODE: Adt_constr_one 331 */

#line 93 "movable_object.ceu"
    CEU_SDL_Rect __ceu_adt_331;

#line 93 "movable_object.ceu"
    {/* NODE: ExpList 330 */
/* NODE: Op2_. 321 */
/* NODE: Op2_. 323 */
/* NODE: Op2_+ 326 */
/* NODE: Op2_+ 329 */

#line 93 "movable_object.ceu"
    __ceu_adt_331.x = (((((CEU_Rect*)_ceu_org)->rect).x));
#line 93 "movable_object.ceu"
    __ceu_adt_331.y = (((((CEU_Rect*)_ceu_org)->rect).y));
#line 93 "movable_object.ceu"
    __ceu_adt_331.w = ((((CEU_Rect*)_ceu_org)->w)+(((CEU_Rect*)_ceu_org)->wn));
#line 93 "movable_object.ceu"
    __ceu_adt_331.h = ((((CEU_Rect*)_ceu_org)->h)+(((CEU_Rect*)_ceu_org)->hn));
#line 93 "movable_object.ceu"
    }
#line 93 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->rect) = __ceu_adt_331;
#line 93 "movable_object.ceu"
    }
#line 92 "movable_object.ceu"
    }
#line 92 "movable_object.ceu"
/* CLEAR: Block (92) */
#line 92 "movable_object.ceu"
    if (0) {

#line 92 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 1085 */

#line 94 "movable_object.ceu"
    if (((((*(((CEU_Rect*)_ceu_org)->but_32)).button))==SDL_BUTTON_RIGHT)) {
/* NODE: Block 362 */

#line 95 "movable_object.ceu"
    {/* NODE: Stmts 361 */

#line 95 "movable_object.ceu"
    {/* NODE: Set 1093 */

#line 95 "movable_object.ceu"
/* SET: hn *//* NODE: Op2_+ 343 */

#line 95 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->hn) = ((((CEU_Rect*)_ceu_org)->hn)+5);/* NODE: Set 1094 */

#line 96 "movable_object.ceu"
/* SET: rect *//* NODE: Adt_constr_root 359 */

#line 96 "movable_object.ceu"
    {/* NODE: Adt_constr_one 358 */

#line 96 "movable_object.ceu"
    CEU_SDL_Rect __ceu_adt_358;

#line 96 "movable_object.ceu"
    {/* NODE: ExpList 357 */
/* NODE: Op2_. 348 */
/* NODE: Op2_. 350 */
/* NODE: Op2_+ 353 */
/* NODE: Op2_+ 356 */

#line 96 "movable_object.ceu"
    __ceu_adt_358.x = (((((CEU_Rect*)_ceu_org)->rect).x));
#line 96 "movable_object.ceu"
    __ceu_adt_358.y = (((((CEU_Rect*)_ceu_org)->rect).y));
#line 96 "movable_object.ceu"
    __ceu_adt_358.w = ((((CEU_Rect*)_ceu_org)->w)+(((CEU_Rect*)_ceu_org)->wn));
#line 96 "movable_object.ceu"
    __ceu_adt_358.h = ((((CEU_Rect*)_ceu_org)->h)+(((CEU_Rect*)_ceu_org)->hn));
#line 96 "movable_object.ceu"
    }
#line 96 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->rect) = __ceu_adt_358;
#line 96 "movable_object.ceu"
    }
#line 95 "movable_object.ceu"
    }
#line 95 "movable_object.ceu"
/* CLEAR: Block (95) */
#line 95 "movable_object.ceu"
    if (0) {

#line 95 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 1084 */

#line 97 "movable_object.ceu"
    if (((((*(((CEU_Rect*)_ceu_org)->but_32)).button))==SDL_BUTTON_MIDDLE)) {
/* NODE: Block 390 */

#line 98 "movable_object.ceu"
    {/* NODE: Stmts 389 */

#line 98 "movable_object.ceu"
    {/* NODE: Set 1097 */

#line 98 "movable_object.ceu"
/* SET: wn *//* NODE: NUMBER 368 */

#line 98 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->wn) = 0;/* NODE: Set 1098 */

#line 99 "movable_object.ceu"
/* SET: hn *//* NODE: NUMBER 371 */

#line 99 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->hn) = 0;/* NODE: Set 1099 */

#line 100 "movable_object.ceu"
/* SET: rect *//* NODE: Adt_constr_root 387 */

#line 100 "movable_object.ceu"
    {/* NODE: Adt_constr_one 386 */

#line 100 "movable_object.ceu"
    CEU_SDL_Rect __ceu_adt_386;

#line 100 "movable_object.ceu"
    {/* NODE: ExpList 385 */
/* NODE: Op2_. 376 */
/* NODE: Op2_. 378 */
/* NODE: Op2_+ 381 */
/* NODE: Op2_+ 384 */

#line 100 "movable_object.ceu"
    __ceu_adt_386.x = (((((CEU_Rect*)_ceu_org)->rect).x));
#line 100 "movable_object.ceu"
    __ceu_adt_386.y = (((((CEU_Rect*)_ceu_org)->rect).y));
#line 100 "movable_object.ceu"
    __ceu_adt_386.w = ((((CEU_Rect*)_ceu_org)->w)+(((CEU_Rect*)_ceu_org)->wn));
#line 100 "movable_object.ceu"
    __ceu_adt_386.h = ((((CEU_Rect*)_ceu_org)->h)+(((CEU_Rect*)_ceu_org)->hn));
#line 100 "movable_object.ceu"
    }
#line 100 "movable_object.ceu"
    (((CEU_Rect*)_ceu_org)->rect) = __ceu_adt_386;
#line 100 "movable_object.ceu"
    }
#line 98 "movable_object.ceu"
    }
#line 98 "movable_object.ceu"
/* CLEAR: Block (98) */
#line 98 "movable_object.ceu"
    if (0) {

#line 98 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 1083 */
}
}
}

#line 90 "movable_object.ceu"
    }
#line 90 "movable_object.ceu"
/* CLEAR: Block (90) */
#line 90 "movable_object.ceu"
    if (0) {

#line 90 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 68 "movable_object.ceu"
/* PAROR JOIN */
#line 68 "movable_object.ceu"
    _ceu_lbl = Rect_ParOr_out_10;
goto _CEU_GOTO_;

#line 68 "movable_object.ceu"
case Rect_ParOr_sub_2_9:;/* NODE: Block 304 */

#line 80 "movable_object.ceu"
    {/* NODE: Stmts 303 */

#line 80 "movable_object.ceu"
    {/* NODE: Stmts 974 */

#line 80 "movable_object.ceu"
    {/* NODE: Dcl_var 971 */
/* NODE: Stmts 1015 */

#line 80 "movable_object.ceu"
    {/* NODE: Nothing 977 */
/* NODE: Set 976 */

#line 80 "movable_object.ceu"
/* SET: table: 0x1d0c630 *//* NODE: Await 255 */

#line 80 "movable_object.ceu"
    _CEU_NO_255_:
if (0) { goto _CEU_NO_255_; /* avoids "not used" warning */ }

#line 80 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYUP;
_ceu_trl->lbl = Rect_Awake_SDL_KEYUP_12;
_ceu_trl->seqno = _ceu_app->seqno;

#line 80 "movable_object.ceu"
    return;

case Rect_Awake_SDL_KEYUP_12:;

#line 80 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 80 "movable_object.ceu"
    {

#line 80 "movable_object.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 80 "movable_object.ceu"
        {
        (((CEU_Rect*)_ceu_org)->key_31) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: Nothing 1352 */
/* NODE: Nothing 1353 */

#line 80 "movable_object.ceu"
    }
#line 80 "movable_object.ceu"
    }/* NODE: If 1023 */

#line 81 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_31)).keysym)).sym))==SDLK_t)) {
/* NODE: Block 271 */

#line 82 "movable_object.ceu"
    {/* NODE: Stmts 270 */

#line 82 "movable_object.ceu"
    {/* NODE: Set 1026 */

#line 82 "movable_object.ceu"
/* SET: clr *//* NODE: Op2_call 268 */

#line 82 "movable_object.ceu"
    {
    SDL_Color __ceu_v_1026 = 
#ifdef __cplusplus
    SDL_Color(0x0A,0x5F,0x4D)
#else
    {0x0A,0x5F,0x4D}
#endif
;
    (((CEU_Rect*)_ceu_org)->clr) = __ceu_v_1026;
}

#line 82 "movable_object.ceu"
    }
#line 82 "movable_object.ceu"
/* CLEAR: Block (82) */
#line 82 "movable_object.ceu"
    if (0) {

#line 82 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 1022 */

#line 83 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_31)).keysym)).sym))==SDLK_y)) {
/* NODE: Block 286 */

#line 84 "movable_object.ceu"
    {/* NODE: Stmts 285 */

#line 84 "movable_object.ceu"
    {/* NODE: Set 1029 */

#line 84 "movable_object.ceu"
/* SET: clr *//* NODE: Op2_call 283 */

#line 84 "movable_object.ceu"
    {
    SDL_Color __ceu_v_1029 = 
#ifdef __cplusplus
    SDL_Color(0x00,0xFF,0xFF)
#else
    {0x00,0xFF,0xFF}
#endif
;
    (((CEU_Rect*)_ceu_org)->clr) = __ceu_v_1029;
}

#line 84 "movable_object.ceu"
    }
#line 84 "movable_object.ceu"
/* CLEAR: Block (84) */
#line 84 "movable_object.ceu"
    if (0) {

#line 84 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 1021 */

#line 85 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_31)).keysym)).sym))==SDLK_u)) {
/* NODE: Block 301 */

#line 86 "movable_object.ceu"
    {/* NODE: Stmts 300 */

#line 86 "movable_object.ceu"
    {/* NODE: Set 1032 */

#line 86 "movable_object.ceu"
/* SET: clr *//* NODE: Op2_call 298 */

#line 86 "movable_object.ceu"
    {
    SDL_Color __ceu_v_1032 = 
#ifdef __cplusplus
    SDL_Color(0x90,0x3A,0x03)
#else
    {0x90,0x3A,0x03}
#endif
;
    (((CEU_Rect*)_ceu_org)->clr) = __ceu_v_1032;
}

#line 86 "movable_object.ceu"
    }
#line 86 "movable_object.ceu"
/* CLEAR: Block (86) */
#line 86 "movable_object.ceu"
    if (0) {

#line 86 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 1020 */
}
}
}

#line 80 "movable_object.ceu"
    }
#line 80 "movable_object.ceu"
/* CLEAR: Block (80) */
#line 80 "movable_object.ceu"
    if (0) {

#line 80 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 68 "movable_object.ceu"
/* PAROR JOIN */
#line 68 "movable_object.ceu"
    _ceu_lbl = Rect_ParOr_out_10;
goto _CEU_GOTO_;

#line 68 "movable_object.ceu"
case Rect_ParOr_sub_1_8:;/* NODE: Block 252 */

#line 69 "movable_object.ceu"
    {/* NODE: Stmts 251 */

#line 69 "movable_object.ceu"
    {/* NODE: Stmts 907 */

#line 69 "movable_object.ceu"
    {/* NODE: Dcl_var 904 */
/* NODE: Stmts 948 */

#line 69 "movable_object.ceu"
    {/* NODE: Nothing 910 */
/* NODE: Set 909 */

#line 69 "movable_object.ceu"
/* SET: table: 0x1ca5c70 *//* NODE: Await 206 */

#line 69 "movable_object.ceu"
    _CEU_NO_206_:
if (0) { goto _CEU_NO_206_; /* avoids "not used" warning */ }

#line 69 "movable_object.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Rect_Awake_SDL_KEYDOWN_11;
_ceu_trl->seqno = _ceu_app->seqno;

#line 69 "movable_object.ceu"
    return;

case Rect_Awake_SDL_KEYDOWN_11:;

#line 69 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 69 "movable_object.ceu"
    {

#line 69 "movable_object.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 69 "movable_object.ceu"
        {
        (((CEU_Rect*)_ceu_org)->key_30) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: Nothing 1350 */
/* NODE: Nothing 1351 */

#line 69 "movable_object.ceu"
    }
#line 69 "movable_object.ceu"
    }/* NODE: If 957 */

#line 70 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_30)).keysym)).sym))==SDLK_a)) {
/* NODE: Block 218 */

#line 71 "movable_object.ceu"
    {/* NODE: Stmts 217 */

#line 71 "movable_object.ceu"
    {/* NODE: EmitInt 216 */

#line 71 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 71 "movable_object.ceu"
    tceu__int __ceu_ps_216;
{
    tceu__int __ceu_ps_216_ =
        {

#line 71 "movable_object.ceu"
                (-10)
#line 71 "movable_object.ceu"
            };

#line 71 "movable_object.ceu"
        __ceu_ps_216 = __ceu_ps_216_;
}

#line 71 "movable_object.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 71 "movable_object.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 71 "movable_object.ceu"
        evt.param = (&__ceu_ps_216);

#line 71 "movable_object.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 71 "movable_object.ceu"
    }
#line 71 "movable_object.ceu"
/* CLEAR: Block (71) */
#line 71 "movable_object.ceu"
    if (0) {

#line 71 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 956 */

#line 72 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_30)).keysym)).sym))==SDLK_d)) {
/* NODE: Block 228 */

#line 73 "movable_object.ceu"
    {/* NODE: Stmts 227 */

#line 73 "movable_object.ceu"
    {/* NODE: EmitInt 226 */

#line 73 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 73 "movable_object.ceu"
    tceu__int __ceu_ps_226;
{
    tceu__int __ceu_ps_226_ =
        {

#line 73 "movable_object.ceu"
                10
#line 73 "movable_object.ceu"
            };

#line 73 "movable_object.ceu"
        __ceu_ps_226 = __ceu_ps_226_;
}

#line 73 "movable_object.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 73 "movable_object.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 73 "movable_object.ceu"
        evt.param = (&__ceu_ps_226);

#line 73 "movable_object.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 73 "movable_object.ceu"
    }
#line 73 "movable_object.ceu"
/* CLEAR: Block (73) */
#line 73 "movable_object.ceu"
    if (0) {

#line 73 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 955 */

#line 74 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_30)).keysym)).sym))==SDLK_w)) {
/* NODE: Block 239 */

#line 75 "movable_object.ceu"
    {/* NODE: Stmts 238 */

#line 75 "movable_object.ceu"
    {/* NODE: EmitInt 237 */

#line 75 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 75 "movable_object.ceu"
    tceu__int __ceu_ps_237;
{
    tceu__int __ceu_ps_237_ =
        {

#line 75 "movable_object.ceu"
                (-10)
#line 75 "movable_object.ceu"
            };

#line 75 "movable_object.ceu"
        __ceu_ps_237 = __ceu_ps_237_;
}

#line 75 "movable_object.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 75 "movable_object.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 75 "movable_object.ceu"
        evt.param = (&__ceu_ps_237);

#line 75 "movable_object.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 75 "movable_object.ceu"
    }
#line 75 "movable_object.ceu"
/* CLEAR: Block (75) */
#line 75 "movable_object.ceu"
    if (0) {

#line 75 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 954 */

#line 76 "movable_object.ceu"
    if (((((((*(((CEU_Rect*)_ceu_org)->key_30)).keysym)).sym))==SDLK_s)) {
/* NODE: Block 249 */

#line 77 "movable_object.ceu"
    {/* NODE: Stmts 248 */

#line 77 "movable_object.ceu"
    {/* NODE: EmitInt 247 */

#line 77 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 77 "movable_object.ceu"
    tceu__int __ceu_ps_247;
{
    tceu__int __ceu_ps_247_ =
        {

#line 77 "movable_object.ceu"
                10
#line 77 "movable_object.ceu"
            };

#line 77 "movable_object.ceu"
        __ceu_ps_247 = __ceu_ps_247_;
}

#line 77 "movable_object.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 77 "movable_object.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 77 "movable_object.ceu"
        evt.param = (&__ceu_ps_247);

#line 77 "movable_object.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 77 "movable_object.ceu"
    }
#line 77 "movable_object.ceu"
/* CLEAR: Block (77) */
#line 77 "movable_object.ceu"
    if (0) {

#line 77 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 953 */
}
}
}
}

#line 69 "movable_object.ceu"
    }
#line 69 "movable_object.ceu"
/* CLEAR: Block (69) */
#line 69 "movable_object.ceu"
    if (0) {

#line 69 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 68 "movable_object.ceu"
/* PAROR JOIN */
#line 68 "movable_object.ceu"
    _ceu_lbl = Rect_ParOr_out_10;
goto _CEU_GOTO_;

#line 68 "movable_object.ceu"
case Rect_ParOr_out_10:;
#line 68 "movable_object.ceu"
/* CLEAR: ParOr (68) */
#line 68 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,4);
#endif
}

#line 68 "movable_object.ceu"
    }
#line 68 "movable_object.ceu"
/* CLEAR: Block (68) */
#line 68 "movable_object.ceu"
    if (0) {

#line 68 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 67 "movable_object.ceu"
    }

#line 67 "movable_object.ceu"
    }
#line 67 "movable_object.ceu"
/* CLEAR: Block (67) */
#line 67 "movable_object.ceu"
    if (0) {

#line 67 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 67 "movable_object.ceu"
    }
#line 67 "movable_object.ceu"
/* CLEAR: Block (67) */
#line 67 "movable_object.ceu"
    if (0) {

#line 67 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "movable_object.ceu"
case Rect_ParOr_sub_1_1:;/* NODE: Block 203 */

#line 51 "movable_object.ceu"
    {/* NODE: Stmts 202 */

#line 51 "movable_object.ceu"
    {/* NODE: ParOr 201 */

#line 51 "movable_object.ceu"
/* ParOr: spawn subs */
#line 51 "movable_object.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 51 "movable_object.ceu"
        _ceu_org->trls[ 0 ].lbl = Rect_ParOr_sub_1_4;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 51 "movable_object.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 51 "movable_object.ceu"
    }
/* NODE: Block 200 */

#line 60 "movable_object.ceu"
    {/* NODE: Stmts 199 */

#line 60 "movable_object.ceu"
    {/* NODE: Block 847 */

#line 60 "movable_object.ceu"
    {/* NODE: Stmts 846 */

#line 60 "movable_object.ceu"
    {/* NODE: Stmts 845 */

#line 60 "movable_object.ceu"
    {
#line 60 "movable_object.ceu"
    }/* NODE: Loop 844 */

#line 60 "movable_object.ceu"
    for (;;) {
/* NODE: Block 197 */

#line 61 "movable_object.ceu"
    {
#line 61 "movable_object.ceu"
    int __ceu_v_29;
/* NODE: Stmts 196 */

#line 61 "movable_object.ceu"
    {/* NODE: Stmts 852 */

#line 61 "movable_object.ceu"
    {/* NODE: Dcl_var 849 */
/* NODE: Stmts 893 */

#line 61 "movable_object.ceu"
    {/* NODE: Nothing 855 */
/* NODE: Set 854 */

#line 61 "movable_object.ceu"
/* SET: table: 0x1ca60d0 *//* NODE: Await 187 */

#line 61 "movable_object.ceu"
    _CEU_NO_187_:
if (0) { goto _CEU_NO_187_; /* avoids "not used" warning */ }

#line 61 "movable_object.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Rect_Awake_go_vert_7;
_ceu_trl->seqno = _ceu_app->seqno;

#line 61 "movable_object.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = _ceu_org;
#endif

#line 61 "movable_object.ceu"
    return;

case Rect_Awake_go_vert_7:;

#line 61 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 61 "movable_object.ceu"
    {

#line 61 "movable_object.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 61 "movable_object.ceu"
        {
        (__ceu_v_29) = ((__ceu_casted)->_1);
    }
}
/* NODE: Nothing 1348 */
/* NODE: Nothing 1349 */

#line 61 "movable_object.ceu"
    }
#line 61 "movable_object.ceu"
    }/* NODE: Set 898 */

#line 62 "movable_object.ceu"
/* SET: . *//* NODE: Op2_+ 194 */

#line 62 "movable_object.ceu"
    (((((CEU_Rect*)_ceu_org)->rect).y)) = ((((((CEU_Rect*)_ceu_org)->rect).y))+(__ceu_v_29));
#line 61 "movable_object.ceu"
    }
#line 61 "movable_object.ceu"
/* CLEAR: Block (61) */
#line 61 "movable_object.ceu"
    if (0) {

#line 61 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 60 "movable_object.ceu"
    }

#line 60 "movable_object.ceu"
    }
#line 60 "movable_object.ceu"
/* CLEAR: Block (60) */
#line 60 "movable_object.ceu"
    if (0) {

#line 60 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 60 "movable_object.ceu"
    }
#line 60 "movable_object.ceu"
/* CLEAR: Block (60) */
#line 60 "movable_object.ceu"
    if (0) {

#line 60 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "movable_object.ceu"
case Rect_ParOr_sub_1_4:;/* NODE: Block 184 */

#line 52 "movable_object.ceu"
    {/* NODE: Stmts 183 */

#line 52 "movable_object.ceu"
    {/* NODE: Block 790 */

#line 52 "movable_object.ceu"
    {/* NODE: Stmts 789 */

#line 52 "movable_object.ceu"
    {/* NODE: Stmts 788 */

#line 52 "movable_object.ceu"
    {
#line 52 "movable_object.ceu"
    }/* NODE: Loop 787 */

#line 52 "movable_object.ceu"
    for (;;) {
/* NODE: Block 181 */

#line 53 "movable_object.ceu"
    {
#line 53 "movable_object.ceu"
    int __ceu_v_28;
/* NODE: Stmts 180 */

#line 53 "movable_object.ceu"
    {/* NODE: Stmts 795 */

#line 53 "movable_object.ceu"
    {/* NODE: Dcl_var 792 */
/* NODE: Stmts 836 */

#line 53 "movable_object.ceu"
    {/* NODE: Nothing 798 */
/* NODE: Set 797 */

#line 53 "movable_object.ceu"
/* SET: table: 0x1cae4b0 *//* NODE: Await 163 */

#line 53 "movable_object.ceu"
    _CEU_NO_163_:
if (0) { goto _CEU_NO_163_; /* avoids "not used" warning */ }

#line 53 "movable_object.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Rect_Awake_go_oriz_6;
_ceu_trl->seqno = _ceu_app->seqno;

#line 53 "movable_object.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = _ceu_org;
#endif

#line 53 "movable_object.ceu"
    return;

case Rect_Awake_go_oriz_6:;

#line 53 "movable_object.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 53 "movable_object.ceu"
    {

#line 53 "movable_object.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 53 "movable_object.ceu"
        {
        (__ceu_v_28) = ((__ceu_casted)->_1);
    }
}
/* NODE: Nothing 1346 */
/* NODE: Nothing 1347 */

#line 53 "movable_object.ceu"
    }
#line 53 "movable_object.ceu"
    }/* NODE: Set 841 */

#line 54 "movable_object.ceu"
/* SET: . *//* NODE: Op2_+ 170 */

#line 54 "movable_object.ceu"
    (((((CEU_Rect*)_ceu_org)->rect).x)) = ((((((CEU_Rect*)_ceu_org)->rect).x))+(__ceu_v_28));/* NODE: If 843 */

#line 55 "movable_object.ceu"
    if (((((((CEU_Rect*)_ceu_org)->rect).x))>1500)) {
/* NODE: Block 178 */

#line 56 "movable_object.ceu"
    {/* NODE: Stmts 177 */

#line 56 "movable_object.ceu"
    {/* NODE: Break 176 */

#line 56 "movable_object.ceu"
    break;
#line 56 "movable_object.ceu"
    }
#line 56 "movable_object.ceu"
/* CLEAR: Block (56) */
#line 56 "movable_object.ceu"
    if (0) {

#line 56 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 842 */
}

#line 53 "movable_object.ceu"
    }
#line 53 "movable_object.ceu"
/* CLEAR: Block (53) */
#line 53 "movable_object.ceu"
    if (0) {

#line 53 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 52 "movable_object.ceu"
    }

#line 52 "movable_object.ceu"
/* CLEAR: Loop (52) */
#line 52 "movable_object.ceu"
    }
#line 52 "movable_object.ceu"
/* CLEAR: Block (52) */
#line 52 "movable_object.ceu"
    if (0) {

#line 52 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 52 "movable_object.ceu"
    }
#line 52 "movable_object.ceu"
/* CLEAR: Block (52) */
#line 52 "movable_object.ceu"
    if (0) {

#line 52 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "movable_object.ceu"
/* PAROR JOIN */
#line 51 "movable_object.ceu"
    _ceu_lbl = Rect_ParOr_out_5;
goto _CEU_GOTO_;

#line 51 "movable_object.ceu"
case Rect_ParOr_out_5:;
#line 51 "movable_object.ceu"
/* CLEAR: ParOr (51) */
#line 51 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 51 "movable_object.ceu"
    }
#line 51 "movable_object.ceu"
/* CLEAR: Block (51) */
#line 51 "movable_object.ceu"
    if (0) {

#line 51 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "movable_object.ceu"
/* PAROR JOIN */
#line 49 "movable_object.ceu"
    _ceu_lbl = Rect_ParOr_out_3;
goto _CEU_GOTO_;

#line 49 "movable_object.ceu"
case Rect_ParOr_out_3:;
#line 49 "movable_object.ceu"
/* CLEAR: ParOr (49) */
#line 49 "movable_object.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  6);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,5);
#endif
}

#line 39 "movable_object.ceu"
    }
#line 39 "movable_object.ceu"
/* CLEAR: Block (39) */
#line 39 "movable_object.ceu"
    if (0) {

#line 39 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 35 "movable_object.ceu"
    }
#line 35 "movable_object.ceu"
/* CLEAR: Block (35) */
#line 35 "movable_object.ceu"
    if (0) {

#line 35 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 35 "movable_object.ceu"
    }
#line 35 "movable_object.ceu"
/* CLEAR: Block (35) */
#line 35 "movable_object.ceu"
    if (0) {

#line 35 "movable_object.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 35 "movable_object.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 35 "movable_object.ceu"
    return;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif

    

#ifdef CEU_OS_APP

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
